<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>sheep | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="View的绘制流程目录

写在前面
最早的canvas是如何得到的（可跳过)
View的绘制过程
ViewGroup的绘制过程
scroll是怎么发生的
其他琐碎的小点

写在前面写这篇文章的原因有以下几点：

在网上找的关于scroll的文章都没有真正解释如何scrollX 和scrollY是如何起作用的。
scrollTo和scrollBy对view有什么作用。
scrollTo和scroll">
<meta property="og:type" content="article">
<meta property="og:title" content="sheep">
<meta property="og:url" content="http://yoursite.com/2016/04/03/sheep/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="View的绘制流程目录

写在前面
最早的canvas是如何得到的（可跳过)
View的绘制过程
ViewGroup的绘制过程
scroll是怎么发生的
其他琐碎的小点

写在前面写这篇文章的原因有以下几点：

在网上找的关于scroll的文章都没有真正解释如何scrollX 和scrollY是如何起作用的。
scrollTo和scrollBy对view有什么作用。
scrollTo和scroll">
<meta property="og:image" content="http://img.my.csdn.net/uploads/201212/08/1354900406_7918.jpg">
<meta property="og:updated_time" content="2016-04-11T04:18:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sheep">
<meta name="twitter:description" content="View的绘制流程目录

写在前面
最早的canvas是如何得到的（可跳过)
View的绘制过程
ViewGroup的绘制过程
scroll是怎么发生的
其他琐碎的小点

写在前面写这篇文章的原因有以下几点：

在网上找的关于scroll的文章都没有真正解释如何scrollX 和scrollY是如何起作用的。
scrollTo和scrollBy对view有什么作用。
scrollTo和scroll">
<meta name="twitter:image" content="http://img.my.csdn.net/uploads/201212/08/1354900406_7918.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-sheep" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/sheep/" class="article-date">
  <time datetime="2016-04-03T07:33:57.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android-ui/">android ui</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      sheep
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h1><p>目录</p>
<ol>
<li><a href="#preliminaries">写在前面</a></li>
<li><a href="#chapter_1">最早的canvas是如何得到的（可跳过)</a></li>
<li><a href="#chapter_2">View的绘制过程</a></li>
<li><a href="#chapter_3">ViewGroup的绘制过程</a></li>
<li><a href="#chapter_4">scroll是怎么发生的</a></li>
<li><a href="#chapter_5">其他琐碎的小点</a></li>
</ol>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><a name="preliminaries"></a>写在前面</h2><p>写这篇文章的原因有以下几点：</p>
<ol>
<li>在网上找的关于scroll的文章都没有真正解释如何scrollX 和scrollY是如何起作用的。</li>
<li><a name="problem_2"><a href="#problem_2_answer">scrollTo和scrollBy对view有什么作用。</a></a></li>
<li><a name="problem_3"><a href="#problem_3_answer">scrollTo和scrollBy对viewGroup有什么作用</a></a></li>
<li>viewGroup是怎么决定child view在画布上的大小和位置的</li>
<li>canvas是如何一层层传下去的。</li>
<li><a href="#problem_6_answer">margin和padding在view的绘制过程中起了什么作用</a>（注意是绘制）</li>
</ol>
<p>还有一些奇奇怪怪的问题，例如view scroll了背景跟着scroll吗<br>这些问题都直接指向了view的draw流程，使人希望对view的draw过程有个更深入的了解。这里主要的侧重点在view的draw过程上，就是<strong>一个view或viewGroup的内容是怎么画在canvas上的</strong>，不对measure和layout pass做更多描述。而且为了简化过程，一下都默认关闭了硬件加速。</p>
<h2 id="最早的canvas是如何得到的-本文不重要"><a href="#最早的canvas是如何得到的-本文不重要" class="headerlink" title="最早的canvas是如何得到的(本文不重要)"></a><a name="chapter_1"></a>最早的canvas是如何得到的(本文不重要)</h2><p>（这部分可以跳过，主要讲的是最早的canvas和draw<br>直接看结论：<strong><em>最根部的view是属于phoneWindow的decorView，它是一个FrameLayout,ViewRootImpl在performTraversal里完成measure pass 和layout pass,然后通过mSurface获取canvas，并调用这个decorView作为FrameLayout的draw方法，把canvas一层层传下去。</em></strong>）</p>
<p><img src="http://img.my.csdn.net/uploads/201212/08/1354900406_7918.jpg" alt="应用程序窗口视图的创建过程"></p>
<p>在<a href="http://blog.csdn.net/luoshengyang/article/details/8245546" target="_blank" rel="external">老罗的博客</a>中，他介绍了activity的窗口对象的创建流程。<br>这不是本文的重点所以不加以赘述。只是简单的描述下过程。(描述过程的原因是博客里的 API 版本过旧，这里用23版本的sdk再走一遍流程，很多地方不是很详细，尤其是performTraversals,这里自己也没有深入去看，只是让自己有个大概的印象，<strong>了解真正的view的绘制过程可以跳过这一节</strong>)</p>
<ol>
<li><p><strong>建立decorView</strong> </p>
<p> Activity中有个mWindow对象。Window其实是一个抽象类，他在sdk里只有一个叫PhoneWindow的实现。当Acitivity在onCreate中setContentView里面调用的就是这个phoneWindow的setContentView。PhoneWindow有一个根视图对象，他其实一个叫做DecorView的FrameLayout。PhoneWindow setContentView时会对decorView初始化。</p>
</li>
<li><p><strong>关联decorView和viewRootImpl</strong></p>
<p> 这一步执行完成后，接下来就是viewRootImp和decorView的关联。decorView初始化后，ActivityThread类的成员函数handleResumeActivity中，就会继续调用当前正在激活的Activity组件的成员函数getWindowManager来获得一个WindowManager。这个windowManager在这个activity attach 的时候就以初始化</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mWindow.setWindowManager(</span><br><span class="line">   (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">   mToken, mComponent.flattenToString(),</span><br><span class="line">   (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>接下来会调用这个windowMangagerImpl中的WindowMangerGlobaladdView的addView来关联一个viewRootImp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">    </span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line">    </span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root);</span><br><span class="line">    mParams.add(wparams);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的<code>root.setView(view, wparams, panelParentView);</code><br>viewRootImpl里有个属性叫mView, 在viewRootImpl的setView里正式把上文提到的decorView绑定到viewRootImpl的mView里，viewRootImpl和decorView的关联就算完成了。</p>
<!-- 怎么改序号啊-->
<ol>
<li><p><strong>【First Traversal 我没想好小标题，以及怎么改序号呀】</strong></p>
<p> 接下来在setView里就开始第一次布局requestLayout</p>
<blockquote>
<p>Schedule the first layout -before- adding to the window manager, to make sure we do the relayout before receiving any other events from the system.</p>
</blockquote>
<p> 在requestLayout里面,viewRootImpl schedule了一次Traversal。它把含有<code>TraversalRunnable</code>的runnable放入了主looper里面<br> &gt;</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        &#125;</span><br><span class="line">        performTraversals();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>performTraversal的代码非常长，在这里并没有细看。了解的大大意是WindowManagerService会去为这个viewRootImpl提供一个有效的绘图表面(mSurface)。在measure， layout 完毕以后会performDraw,performDraw里又会调用draw。在没有硬件加速的情况下，会调用</p>
<p><code>drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)</code></p>
<h4 id="这里到了这一小节真正的重点-canvas是如何得到的"><a href="#这里到了这一小节真正的重点-canvas是如何得到的" class="headerlink" title="这里到了这一小节真正的重点 canvas是如何得到的"></a>这里到了这一小节真正的重点 <strong><em>canvas是如何得到的</em></strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span><br><span class="line">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">        ...</span><br><span class="line">         mView.draw(canvas);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在上文中我们已经获得surface，另外这里的dirty实际是由这个decoreView的宽高获得的Rect, <code>mSurface.lockCanvas(dirty)</code>获得了要绘制到这个surface的canvas。</p>
<p>并且 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">将这个canvas传给了decorView，这个FrameLayout，也就是一个***View的draw方法***。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## &lt;a name=&quot;chapter_2&quot;&gt;&lt;/a&gt;View的绘制过程</span><br><span class="line">在view里面有两个draw方法，真正的本体是参数为canvas的`public void draw(Canvas canvas)`的draw方法，任何一个view关于自己的绘制本质上都是在这个draw里完成的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个view的draw过程分为六步</span><br><span class="line">&gt;        1. Draw the background</span><br><span class="line">       2. If necessary, save the canvas&apos; layers to prepare for fading</span><br><span class="line">       3. Draw view&apos;s content</span><br><span class="line">       4. Draw children</span><br><span class="line">       5. If necessary, draw the fading edges and restore layers</span><br><span class="line">       6. Draw decorations (scrollbars for instance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">首先，我们先看看common case ，忽略要画fading edge效果啊，scrollbar 这类特殊的效果。并且以下的分析都忽略RenderNode等情况。</span><br><span class="line">所以正常一个view的绘制过程主要的就只有四步</span><br><span class="line"></span><br><span class="line">####Step 1, draw the background, if needed</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">    if (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);//在view的draw方法里</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们在<code>drawBackground(canvas)</code>里第一次发现了scrollX，scrollY的踪迹</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">    <span class="keyword">if</span> (background == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setBackgroundBounds();</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">    <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        canvas.translate(scrollX, scrollY);</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">        canvas.translate(-scrollX, -scrollY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，background是一个drawable，通过setBackgroundBounds()将drawable设定在<code>(0, 0,  mRight - mLeft, mBottom - mTop)</code>这样一个Rect范围内。在layout过程中，view的layout方法里<code>setFrame(l, t, r, b);</code>，mLeft,mRight,mBottom,mTop被赋值，这个值在layout的过程中相对于view parent得到的位置信息。那么我们能看到这个位置信息决定了背景drawable 的大小。<br>然后，drawBackground会调用这个作为background的drawable 的draw方法。例如是一个纯色的背景，那么在这个colorDrawable的draw方法里<code>canvas.drawRect(getBounds(), mPaint);</code>把背景颜色画到view的mLeft,mRight,mBottom,mTop决定的大小范围内。<br>那么这样一个view的background就画完了。</p>
<blockquote>
<p><a name="answer_margin"></a>这里就解决了一个平常经常使用但从来没深入了解的问题。margin在一个view的绘制过程中，起了什么作用？</p>
<p>通常我们在onLayout的过程里，决定这个view相对于View Parent的位置时，都会把margin计算在内<code>childLeft = paddingLeft + lp.leftMargin;</code>，<strong><em>所以margin的区域，不在画背景画内容的范围之内。</em></strong></p>
</blockquote>
<p>####Step 2, draw the content<br>在没有fading edge 的情况下，也就是大多数情况下，就开始正式绘制内容了！<br>正式绘制内容对于一个单纯的view来说很简单，就是draw会把自己的canvas原封不动的传下去，在刚刚的background内容上调用常写的<strong><em>onDraw</em></strong>。在里面完成了真正的<strong><em>内容的绘制</em></strong>（padding也是在这里处理的哦！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line"><span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we're done...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里提一个问题，假设我们能得到decorView，对他scrollTo,那会有效果吗？</p>
</blockquote>
<p>####Step 3, draw the children<br><code>dispatchDraw(canvas)</code>就是用来drawChildren的。对于一个普通的view来说他的默认实现是空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called by draw to draw the child views. This may be overridden</span><br><span class="line"> * by derived classes to gain control just before its children are drawn</span><br><span class="line"> * (but after its own view has been drawn).</span><br><span class="line"> * <span class="doctag">@param</span> canvas the canvas on which to draw the view</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个最典型的实现就是ViewGroup绘制自己的子view，把child绘制在自己的content之上。这个将会出现在下一小节。</p>
<p>####Step 4, draw decorations (foreground, scrollbars)<br>正常情况下的最后一步，就是draw 这个view的foreground content了。例如说，scrollBar和通过<code>public void setForeground(Drawable foreground)</code>设置的drawable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"><span class="comment">// we're done...</span></span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>onDrawForeground的javaDoc是这样说的</p>
<blockquote>
<p>   /**</p>
<pre><code>* Draw any foreground content for this view.
*
* &lt;p&gt;Foreground content may consist of scroll bars, a {@link #setForeground foreground}
* drawable or other view-specific decorations. The foreground is drawn on top of the
* primary view content.&lt;/p&gt;
*
* @param canvas canvas to draw into
*/
</code></pre></blockquote>
<p>至此，到了return，一个view的绘制流程就结束了。</p>
<h2 id="ViewGroup的绘制过程"><a href="#ViewGroup的绘制过程" class="headerlink" title="ViewGroup的绘制过程"></a><a name="chapter_3"></a>ViewGroup的绘制过程</h2><p>viewGroup的本质上就是一个view，因此common case下和view的绘制过程一模一样。先画自己的背景，再画自己的内容。接下来，就到了他们不太一样的的地方，也就是第三步，画子view。view的dispatchDraw的默认实现为空，而viewGroup重写了这个方法。<br>在dispatchDraw里面viewGroup干的第一件事就是做<a href="http://developer.android.com/intl/zh-cn/training/animation/layout.html" target="_blank" rel="external">layoutAnimation</a>。layoutAnimation是一个ViewGroup添加或移除view，view的可见性发生改变的时候产生的动画</p>
<!--其实可见性发生改变的时候，触发动画的位置还没找到-->
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((flags &amp; FLAG_RUN_ANIMATION) != <span class="number">0</span> &amp;&amp; canAnimate()) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> buildCache = !isHardwareAccelerated();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</span><br><span class="line">            <span class="keyword">final</span> LayoutParams params = child.getLayoutParams();</span><br><span class="line">            attachLayoutAnimationParameters(child, params, i, childrenCount);</span><br><span class="line">            bindLayoutAnimation(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LayoutAnimationController controller = mLayoutAnimationController;</span><br><span class="line">    <span class="keyword">if</span> (controller.willOverlap()) &#123;</span><br><span class="line">        mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    controller.start();</span><br><span class="line"></span><br><span class="line">    mGroupFlags &amp;= ~FLAG_RUN_ANIMATION;</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_ANIMATION_DONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAnimationListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAnimationListener.onAnimationStart(controller.getAnimation());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这在本文中不是重点，我们的重点主要是解决之前提到的那几个疑惑。<br>在padding不为空和CLIP_TO_PADDING的情况下（默认情况下就是CLIP_TO_PADDING的，代表『When set, ViewGroup excludes the padding area from the invalidate rectangle Set by default』）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">    clipSaveCount = canvas.save();</span><br><span class="line">    canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,</span><br><span class="line">            mScrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">            mScrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来，根据scrollX，scrollY和padding又重新调整画布大小<br>我们可以看到单纯作为viewGroup，padding对于画布就是在这里起作用的。clipRect限制了画布的可见范围，所有默认的viewGroup可见范围都在刨除padding的范围以内。</p>
<p><em><a name="problem_6_answer"></a>注意这里margin和padding的区别：就像<a href="#answer_margin">刚刚讨论的一样</a>，对于背景来说，margin在背景范围之外，发生在draw的第一步<code>drawBackground(Canvas canvas)</code>，而padding发生在dispatchdraw,也就是drawBackground以后，这时背景已经绘制出来了。</em></p>
<p>接下来，我们继续忽略transientChild这样的特殊情况<br>找到重点<br>在这块canvas里（Viewroup.java Line:3398）<br>&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">&#125;</span><br><span class="line">~~~    </span><br><span class="line">&gt;drawChild里面，调用的是child的` <span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span>`方法，这个方法不同于真正用于绘制的draw方法，是专门提供给viewGroup调用来画子view。</span><br><span class="line"></span><br><span class="line">在子view的 <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span>中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">    <span class="keyword">int</span> sx </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!drawingWithRenderNode) &#123;</span><br><span class="line">        computeScroll();</span><br><span class="line">        sx = mScrollX;</span><br><span class="line">        sy = mScrollY;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里可以看到，在写scroller时需要重写的 computeScroll();<code>computeScroll()</code>里面要干的事就是对view的mScrollX，mScrollY重新赋值，并预约下一次invalidate,从而可以预定下次draw。使用scroller的话就是，scroller通过computeScrollOffset()对scroller计算应滑到位置mCurrX和mCurrY的值，我们重写<code>computeScroll()</code>，调用<code>computeScrollOffset()</code>,并把计算出的mCurrX和mCurrY的值赋给mScrollX，mScrollY，然后像上面说的invalidate一下（可以直接调用scrollTo，内含invalidate），从而draw。关于scroller中computeScroll后面再议，不过View中默认是空的实现。</p>
</blockquote>
<p>接下来，我们来到重点<br>首先画布会保存一下，为将来平移做准备</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> restoreTo = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!drawingWithRenderNode || transformToApply != <span class="keyword">null</span>) &#123;</span><br><span class="line">    restoreTo = canvas.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后开始canvas平移</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (offsetForScroll) &#123;</span><br><span class="line">    canvas.translate(mLeft - sx, mTop - sy);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!drawingWithRenderNode) &#123;</span><br><span class="line">    <span class="comment">// apply clips directly, since RenderNode won't do it for this draw</span></span><br><span class="line">    <span class="keyword">if</span> ((parentFlags &amp; ViewGroup.FLAG_CLIP_CHILDREN) != <span class="number">0</span> &amp;&amp; cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offsetForScroll) &#123;</span><br><span class="line">            canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!scalingRequired || cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">                canvas.clipRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                canvas.clipRect(<span class="number">0</span>, <span class="number">0</span>, cache.getWidth(), cache.getHeight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!drawingWithDrawingCache) &#123;</span><br><span class="line"><span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        draw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对，你看的没错，当我们的view.scrollTo里面的参数是正数的时候，canvas的坐标其实向上，向左移动。<code>canvas.translate(mLeft - sx, mTop - sy);</code>，然后<code>canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());</code>裁剪画布大小，使绘制内容不会超过这个大小范围内，然后以新的坐标原点为基础，进行接下来的绘制。</p>
<p>在这个draw方法里，我们可以看到，这个child view，当前调用<code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>的这个view，有可能完全不会进入正常的draw流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line"><span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那什么情况下会不走draw方法（自然ondraw也不会被调用），直接dispatchDraw呢?<br>通常情况下，当前view是viewGroup，且没有背景的时候。<br>这个结论是如何得出来的呢？我们来看看上面的代码，基本上决定是否跳过draw的就是这个条件<code>((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW)</code>。<code>mPrivateFlags</code>是本view的一些标记，例如是否获得焦点<code>PFLAG_FOCUSED</code>，是否可以选中<code>PFLAG_SELECTED</code>等等。一个View的<code>toString()</code>方法，可以看到这个view的flag信息。在这里我们关注的点是，是否<code>PFLAG_SKIP_DRAW</code>。这个flag是在哪设的呢？通过studio analyze data to here 的功能，我们可以找到方法<code>void setFlags(int flags, int mask)</code>,默认的权限是default，也就是同一包内可见。其中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mViewFlags &amp; WILL_NOT_DRAW) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mBackground != <span class="keyword">null</span></span><br><span class="line">                || (mForegroundInfo != <span class="keyword">null</span> &amp;&amp; mForegroundInfo.mDrawable != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPrivateFlags |= PFLAG_SKIP_DRAW;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>我们发现只有设立了WILL_NOT_DRAW，就会跳过draw过程直接dispatch。前提是没有背景和前景，有背景或前景这个flag依旧会失效，draw方法还是会被调用。<br>在viewGroup初始化的地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViewGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ViewGroup doesn't draw by default</span></span><br><span class="line">        <span class="keyword">if</span> (!debugDraw()) &#123;</span><br><span class="line">            setFlags(WILL_NOT_DRAW, DRAW_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>ViewGroup本身默认情况下是不会调用draw的，所以viewGroup的ondraw 在绘制过程中不一定会被调用</em></strong>，除非通过<code>public void setWillNotDraw(boolean willNotDraw)</code>修改这个flag, 或者给这个view添加背景。</p>
<p>一旦调用draw方法，就进入了viewGroup的正常draw流程。</p>
<p>draw,onDraw,dispatchDraw都是可继承的，我们可以关了硬件加速，然后继承View和ViewGroup在这三个方法里写log证明上述顺序，这里就不贴代码了。</p>
<h2 id="scroll是怎么发生的"><a href="#scroll是怎么发生的" class="headerlink" title="scroll是怎么发生的"></a><a name="chapter_4"></a>scroll是怎么发生的</h2><p>我们首先需要明确一个问题，刚刚说的<code>void draw(Canvas canvas)</code>，<code>dispatchDraw(canvas)</code>和<code>boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>三个方法，对于同一个view来说，调用顺序是什么样的？<br>答案是<code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>先调用。</p>
<blockquote>
<p>为什么呢？<br>通过第二个部分的结论我们可以知道，在整个view绘制过程中，最根部的是decorView的<code>void draw(Canvas canvas)</code>。我们视图上的任何layout都是他的子view。<br>那么decorView作为FrameLayout会dispatchDraw(canvas)。那么我们自己layout的根view，有可能是view有可能是viewGroup的，他的<code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>都会先被调用，接下来再根据具体情况，看要不要<code>void draw(Canvas canvas)</code>或直接分发。同理，绘制过程中，每个view最先被调用的，都是draw(Canvas canvas, ViewGroup parent, long drawingTime)，因为他们总是另一个viewGroup的子view。</p>
<p>当我们的对某个view通过scrollTo，scrollBy修改scrollX或srollY的时候，因为invalidate，他会在将来某个时间内重新draw<!--其实invalidate这个过程还没有太弄清楚-->。而这个view一定是某个view的子view，所以因为<code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>会先被调用。</p>
</blockquote>
<p>如上文所说，在<code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>里面，如果不用cache的话会先调用<code>canvas.translate(mLeft - sx, mTop - sy);</code><br>里面的参数是正数的时候，canvas的坐标其实向上，向左移动，那么view新的绘制位置其实是比原来的。所以很多书给了一个『内容窗口』的概念，说有一个『内容窗口』，当scrollX，scrollY的值大于0，这个窗口会下移，导致view的内容下移。</p>
<p>事实上发生的事是，<strong><em>首先,保存画布，canvas坐标与scroll反方向移</em></strong>（也就是<code>canvas.translate(mLeft - sx, mTop - sy);</code>），如果单纯只是这样，我们会发现所有内容，连边界一起都不在原来的位置了。为了保证边界还在原来的位置，<code>canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());</code>,剪裁一个view大小的可见范围。并且由于这是相对于新的，已经平移过的坐标系的，所以还要加上坐标平移的距离<code>(sx, sy, sx + getWidth(), sy + getHeight())</code>，<strong><em>让这个可见范围还在原来没平移之前的位置上</em></strong>。这也就是所谓的『内容窗口』下移。注意，这里坐标系已经变了，与scroll反方向移动，只是可见rect还在原来的位置上,接下来画的内容在已经改变的坐标系基础上的。接着就是正常的draw流程。第一步画背景，按照新的坐标系，背景内容相对于旧的也会平移，所以我们有可能看到背景的边界。而scroll设计的作用就是希望让view的内容进行移动，不是背景。所以像上文提到的<code>drawBackground(canvas)</code>，其中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.translate(scrollX, scrollY);</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">        canvas.translate(-scrollX, -scrollY);</span><br></pre></td></tr></table></figure>
<p>先把坐标系恢复原样，画上背景，再改成scroll后的坐标系。而view的真正内容，包括ViewGroup的子view，都按scroll后的坐标系来画</p>
<p>这样就造成了<strong><em>造成了视觉效果上，scollX&gt;0 scrollY&gt;0，view的内容向左移 和向上移</em></strong></p>
<h2 id="其他琐碎的小点"><a href="#其他琐碎的小点" class="headerlink" title="其他琐碎的小点"></a><a name="chapter_5"></a>其他琐碎的小点</h2><!--hardware acceleration
    renderNode
    LAYER_TYPE_SOFT cache
viewGroup trasient child
fading edges
scroller-->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/03/sheep/" data-id="cimvl2e190001toobko80mc34" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android源码/">android源码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/canvas/">canvas</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/draw/">draw</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scroll/">scroll</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/04/03/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android-ui/">android ui</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android源码/">android源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/canvas/">canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/draw/">draw</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scroll/">scroll</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/android源码/" style="font-size: 10px;">android源码</a> <a href="/tags/canvas/" style="font-size: 10px;">canvas</a> <a href="/tags/draw/" style="font-size: 10px;">draw</a> <a href="/tags/scroll/" style="font-size: 10px;">scroll</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/03/sheep/">sheep</a>
          </li>
        
          <li>
            <a href="/2016/04/03/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>